#version 450

// 2D Raytracing compute shader for BGE
layout(local_size_x = 16, local_size_y = 16) in;

// Input/Output textures
layout(binding = 0, rgba32f) uniform writeonly image2D lightMap;
layout(binding = 1, r32ui) uniform readonly uimage2D worldData;
layout(binding = 2, rgba32f) uniform readonly image2D previousFrame;

// Material properties buffer
layout(binding = 3, std430) readonly buffer MaterialProperties {
    vec4 emission[256];      // RGB emission + intensity
    vec4 surface[256];       // absorption, scattering, transmission, metallic
    vec4 thermal[256];       // roughness, refractionIndex, subsurface, anisotropy
} materials;

// Light sources buffer
layout(binding = 4, std430) readonly buffer LightSources {
    vec4 position[64];      // XY position, Z radius, W intensity
    vec4 color[64];         // RGB color + type
} lights;

// Uniforms
layout(binding = 5) uniform RaytracingUniforms {
    uvec2 worldSize;
    uvec2 lightMapSize;
    uint lightCount;
    uint maxBounces;
    uint sampleCount;
    float rayDensity;
    float timeAccumulation;
    uint frameCount;
};

// Constants
const float PI = 3.14159265359;
const float RAY_EPSILON = 0.001;
const float MAX_RAY_DISTANCE = 1000.0;
const float MIN_RAY_INTENSITY = 0.01;

// Ray structure
struct Ray {
    vec2 origin;
    vec2 direction;
    vec3 color;
    float intensity;
    int bounces;
};

struct RayHit {
    bool hit;
    vec2 position;
    vec2 normal;
    uint materialId;
    float distance;
};

// Random number generation
uint rngState;

uint rand() {
    rngState ^= rngState << 13u;
    rngState ^= rngState >> 17u;
    rngState ^= rngState << 5u;
    return rngState;
}

float randf() {
    return float(rand()) / float(0xFFFFFFFFu);
}

vec2 randomDirection() {
    float angle = randf() * 2.0 * PI;
    return vec2(cos(angle), sin(angle));
}

// Sample hemisphere around normal
vec2 sampleHemisphere(vec2 normal, float roughness) {
    float cosTheta = pow(randf(), 1.0 / (roughness + 1.0));
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    float phi = randf() * 2.0 * PI;
    
    vec2 localDir = vec2(sinTheta * cos(phi), cosTheta);
    
    // Transform to world space (2D tangent space)
    vec2 tangent = vec2(-normal.y, normal.x);
    return localDir.x * tangent + localDir.y * normal;
}

// Ray-world intersection
bool traceRay(Ray ray, out RayHit hit) {
    hit.hit = false;
    hit.distance = MAX_RAY_DISTANCE;
    
    vec2 currentPos = ray.origin;
    vec2 rayStep = ray.direction * 0.5; // Sub-pixel stepping
    float totalDistance = 0.0;
    
    // DDA-style raymarching through world grid
    for (int i = 0; i < int(MAX_RAY_DISTANCE * 2.0); ++i) {
        currentPos += rayStep;
        totalDistance += 0.5;
        
        if (totalDistance > MAX_RAY_DISTANCE) break;
        
        ivec2 gridPos = ivec2(floor(currentPos));
        if (gridPos.x < 0 || gridPos.y < 0 || 
            gridPos.x >= int(worldSize.x) || gridPos.y >= int(worldSize.y)) {
            break;
        }
        
        uint materialId = imageLoad(worldData, gridPos).r;
        if (materialId != 0u) {
            hit.hit = true;
            hit.position = currentPos;
            hit.materialId = materialId;
            hit.distance = totalDistance;
            
            // Calculate surface normal (simple gradient-based)
            vec2 gradient = vec2(0.0);
            for (int dx = -1; dx <= 1; dx++) {
                for (int dy = -1; dy <= 1; dy++) {
                    ivec2 samplePos = gridPos + ivec2(dx, dy);
                    if (samplePos.x >= 0 && samplePos.y >= 0 && 
                        samplePos.x < int(worldSize.x) && samplePos.y < int(worldSize.y)) {
                        uint sampleMat = imageLoad(worldData, samplePos).r;
                        if (sampleMat != 0u) {
                            gradient += vec2(dx, dy);
                        }
                    }
                }
            }
            
            if (length(gradient) > 0.0) {
                hit.normal = normalize(gradient);
            } else {
                hit.normal = -ray.direction;
            }
            
            break;
        }
    }
    
    return hit.hit;
}

// Calculate lighting contribution from a single light source
vec3 calculateDirectLighting(vec2 position, vec2 normal, uint lightIndex) {
    vec2 lightPos = lights.position[lightIndex].xy;
    float lightRadius = lights.position[lightIndex].z;
    float lightIntensity = lights.position[lightIndex].w;
    vec3 lightColor = lights.color[lightIndex].rgb;
    
    vec2 lightDir = lightPos - position;
    float lightDistance = length(lightDir);
    
    if (lightDistance > lightRadius) return vec3(0.0);
    
    lightDir /= lightDistance;
    
    // Check for shadows
    Ray shadowRay;
    shadowRay.origin = position + normal * RAY_EPSILON;
    shadowRay.direction = lightDir;
    shadowRay.intensity = 1.0;
    shadowRay.bounces = 0;
    
    RayHit shadowHit;
    if (traceRay(shadowRay, shadowHit) && shadowHit.distance < lightDistance) {
        // In shadow - calculate transmission through material
        uint shadowMaterialId = shadowHit.materialId;
        float transmission = materials.surface[shadowMaterialId].z;
        if (transmission < 0.01) return vec3(0.0);
        lightIntensity *= transmission;
    }
    
    // Calculate attenuation
    float attenuation = 1.0 - (lightDistance / lightRadius);
    attenuation = attenuation * attenuation; // Quadratic falloff
    
    // Lambert's cosine law
    float lambertian = max(dot(normal, lightDir), 0.0);
    
    return lightColor * lightIntensity * attenuation * lambertian;
}

// Calculate global illumination using monte carlo sampling
vec3 calculateGlobalIllumination(vec2 position, vec2 normal, uint materialId) {
    vec3 indirectLight = vec3(0.0);
    
    // Material properties
    float roughness = materials.thermal[materialId].x;
    vec3 albedo = materials.emission[materialId].rgb;
    
    // Sample multiple directions for global illumination
    for (uint i = 0u; i < sampleCount; ++i) {
        vec2 sampleDir = sampleHemisphere(normal, roughness);
        
        Ray giRay;
        giRay.origin = position + normal * RAY_EPSILON;
        giRay.direction = sampleDir;
        giRay.intensity = 1.0;
        giRay.bounces = 0;
        
        RayHit giHit;
        if (traceRay(giRay, giHit)) {
            // Get material emission
            vec3 emission = materials.emission[giHit.materialId].rgb;
            float emissionIntensity = materials.emission[giHit.materialId].w;
            
            if (emissionIntensity > 0.0) {
                float distance = giHit.distance;
                float attenuation = 1.0 / (1.0 + distance * distance * 0.01);
                indirectLight += emission * emissionIntensity * attenuation;
            }
        }
    }
    
    return indirectLight * albedo / float(sampleCount);
}

// Main raytracing function
vec3 tracePixel(ivec2 pixelCoord) {
    vec2 worldPos = vec2(pixelCoord) * vec2(worldSize) / vec2(lightMapSize);
    uint materialId = imageLoad(worldData, ivec2(worldPos)).r;
    
    if (materialId == 0u) return vec3(0.0); // Empty space
    
    vec3 totalLighting = vec3(0.0);
    
    // Calculate surface normal (simplified for 2D)
    vec2 normal = vec2(0.0, 1.0); // Default upward normal
    
    // Self-emission
    vec3 emission = materials.emission[materialId].rgb;
    float emissionIntensity = materials.emission[materialId].w;
    totalLighting += emission * emissionIntensity;
    
    // Direct lighting from all light sources
    for (uint i = 0u; i < lightCount; ++i) {
        totalLighting += calculateDirectLighting(worldPos, normal, i);
    }
    
    // Global illumination (if enabled and within bounces limit)
    if (maxBounces > 0u && sampleCount > 0u) {
        totalLighting += calculateGlobalIllumination(worldPos, normal, materialId);
    }
    
    return totalLighting;
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    
    if (pixelCoord.x >= int(lightMapSize.x) || pixelCoord.y >= int(lightMapSize.y)) {
        return;
    }
    
    // Initialize random seed based on pixel coordinate and frame
    rngState = uint(pixelCoord.x + pixelCoord.y * int(lightMapSize.x) + int(frameCount) * 12345u);
    
    // Trace lighting for this pixel
    vec3 currentLighting = tracePixel(pixelCoord);
    
    // Temporal accumulation for noise reduction
    if (timeAccumulation > 0.0 && frameCount > 0u) {
        vec3 previousLighting = imageLoad(previousFrame, pixelCoord).rgb;
        currentLighting = mix(currentLighting, previousLighting, timeAccumulation);
    }
    
    // Store result
    imageStore(lightMap, pixelCoord, vec4(currentLighting, 1.0));
}